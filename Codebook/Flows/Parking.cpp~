#include <bits/stdc++.h>
using namespace std;

const int N = 105;

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

int adj[3 * N][3 * N];
int tem[3 * N][3 * N];
int par[3 * N], seen[3 * N];

int car[N][N], park[N][N];
int dis[N][N], vis[N][N];
char mat[N][N];

int n, m;
int count_cars, count_spots;

struct Parking{

	bool isValid(int x, int y){
		return (x >= 1 && x <= n && y >= 1 && y <= m);
	}
        
    // BFS from car at (i, j)
	void explore(int i, int j){
		
		memset(vis, 0, sizeof vis);
		memset(dis, 0, sizeof dis);
		queue < pair < int, int > > q;
		q.push({i, j});
		vis[i][j] = 1;
		
		while(!q.empty()){
			
			int x = q.front().first, y = q.front().second;
			q.pop();
			
			for(int k = 0; k < 4; k++){
				int nx = x + dx[k], ny = y + dy[k];
				if(isValid(nx, ny) && !vis[nx][ny] && mat[nx][ny] != 'X'){
					vis[nx][ny] = 1;
					dis[nx][ny] = dis[x][y] + 1;
					if(mat[nx][ny] == 'P'){
						adj[car[i][j]][park[nx][ny]] = dis[nx][ny];
					}
					q.push({nx, ny});
				}
			}
		}
	}
        
    // Maximum-flow 
	bool augmenting_path(int u){
		seen[u] = true;
		if(u == 201) return true;
		for(int i = 0; i <= 201; i++){
			if(tem[u][i] > 0 && !seen[i]){
				par[i] = u;
				if(augmenting_path(i)) return true;
			}
		}
		return false;
	}
	
	int flow(){
		memset(seen, 0, sizeof seen);
		int res = 0;
		par[0] = 0;
		while(augmenting_path(0)){
			res = res + 1;
			int node = 201;
			while(node != 0){
				tem[par[node]][node]--;
				tem[node][par[node]]++;
				node = par[node];
			}
			memset(seen, 0, sizeof seen);
		}
		return res; 
	}

	bool solve(int x){
		
		memset(tem, 0, sizeof tem);
		// Edges between cars and parking spots
		for(int i = 1; i <= 100; i++){
			for(int j = 101; j <= 200; j++){
				if(adj[i][j] != -1){
					tem[i][j] = (adj[i][j] <= x);	
				}
			}
		}

		// Edges between source and car / parking spot and sink
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= m; j++){
				if(car[i][j] != -1){
					tem[0][car[i][j]] = 1;
				}
				if(park[i][j] != -1){
					tem[park[i][j]][201] = 1;
				}
			}
		}

		return (flow() == count_cars);
	}

	int minTime(vector < string > s){
		
		n = (int) s.size(), m = (int) s[0].size();
		count_cars = 0, count_spots = 0;
		memset(adj, -1, sizeof adj);
		
		// 0 = Source
		// [1, 100] = Cars
		// [101, 200] = Parking Spots
		// 201 = Sink

		for(int i = 0; i < n; i++){
			for(int j = 0; j < m; j++){
				mat[i + 1][j + 1] = s[i][j];
				car[i + 1][j + 1] = park[i + 1][j + 1] = -1;
				if(s[i][j] == 'C'){
					car[i + 1][j + 1]  = ++count_cars;
				}
				if(s[i][j] == 'P'){
					park[i + 1][j + 1] = 100 + (++count_spots);
				}
			}
		}
		
		// Find shortest distance from each car to each parking spot
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= m; j++){
				if(mat[i][j] == 'C') explore(i, j);
			}
		}

		// Binary search on answer
		int l = 0, r = n * m, ans = -1;
		while(l <= r){
			int mid = (l + r) >> 1;
			if(solve(mid)){
				ans = mid;
				r = mid - 1;
			}
			else{
				l = mid + 1;
			}
		}

		return ans;
	}
};
